import json
import os
import re
import time

import boto3


logs = boto3.client("logs")
ssm = boto3.client("ssm")
secrets = boto3.client("secretsmanager")
s3 = boto3.client("s3")
sns = boto3.client("sns")
bedrock = boto3.client("bedrock-runtime")


REPORT_TEMPLATE = """# Incident Report: {incident_id} -- {title}

## 1. Executive Summary
- Impact: {impact}
- Customer/User Symptoms: {symptoms}
- Detection Method (alarm/logs): {detection}
- Severity: {severity}
- Start Time (UTC): {start_time}
- End Time (UTC): {end_time}
- Duration: {duration}

## 2. Timeline (UTC)
| Time | Signal | Evidence |
|------|--------|----------|
| {alarm_time} | Alarm triggered | {alarm_name} |
| {first_error_time} | First error seen | logs |
| {triage_time} | Triage started | n/a |
| {rca_time} | Root cause identified | n/a |
| {fix_time} | Fix applied | n/a |
| {restore_time} | Service restored | n/a |
| {alarm_clear_time} | Alarm cleared | n/a |

## 3. Scope and Blast Radius
- Affected components: {components}
- Entry point (ALB / WAF): {entry_point}
- Downstream dependency (RDS): {downstream}
- Regions/AZs: {regions}

## 4. Evidence Collected
### 4.1 CloudWatch Alarm
- Alarm name: {alarm_name}
- Metric: {alarm_metric}
- Threshold: {alarm_threshold}
- State changes: {alarm_state}

### 4.2 App Logs (CloudWatch Logs Insights)
- Error rate over time (1m bins): {app_log_summary}

### 4.3 WAF Logs (CloudWatch Logs Insights)
- Allow vs Block: {waf_log_summary}

### 4.4 Configuration Sources (for Recovery)
- Parameter Store: {ssm_path}
- Secrets Manager: {secret_name} (host/port/dbname/username/password)
- Notes on drift: {drift_notes}

## 5. Root Cause Analysis
- Root cause category: {root_cause_category}
- Exact failure mechanism: {failure_mechanism}
- Why it wasn't prevented: {why_not_prevented}
- Contributing factors: {contributing_factors}

## 6. Resolution
- Actions taken: {actions_taken}
- Validation checks: {validation_checks}
- Evidence of recovery (curl + alarm OK + logs stabilized): {recovery_evidence}

## 7. Preventive Actions
- Immediate (today): {prevent_immediate}
- Short-term (1-2 weeks): {prevent_short}
- Long-term (1-2 months): {prevent_long}

## 8. Appendix
- Key CLI commands used: {cli_commands}
- Logs Insights queries used: {queries_used}
- Report generated by: Amazon Bedrock model {model_id}
"""


def run_logs_query(log_group, query, start_time, end_time, limit=100):
    try:
        resp = logs.start_query(
            logGroupName=log_group,
            startTime=start_time,
            endTime=end_time,
            queryString=query,
            limit=limit,
        )
    except Exception:
        return []
    query_id = resp.get("queryId")
    if not query_id:
        return []
    for _ in range(20):
        result = logs.get_query_results(queryId=query_id)
        if result.get("status") == "Complete":
            return result.get("results", [])
        time.sleep(1.5)
    return []


def slugify(value):
    value = re.sub(r"[^A-Za-z0-9_-]+", "-", value)
    return value.strip("-").lower() or "incident"


def parse_alarm_event(event):
    alarm = None
    if isinstance(event, dict) and "Records" in event:
        try:
            alarm = json.loads(event["Records"][0]["Sns"]["Message"])
        except Exception:
            alarm = event
    else:
        alarm = event
    return alarm if isinstance(alarm, dict) else {}


def bedrock_generate_summary(model_id, prompt_text):
    if not model_id:
        return "Bedrock not configured."

    if model_id.startswith("anthropic."):
        payload = {
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 512,
            "temperature": 0.4,
            "messages": [
                {"role": "user", "content": [{"type": "text", "text": prompt_text}]}
            ],
        }
    else:
        payload = {"inputText": prompt_text}

    try:
        resp = bedrock.invoke_model(
            modelId=model_id,
            contentType="application/json",
            accept="application/json",
            body=json.dumps(payload),
        )
        body = resp.get("body")
        if not body:
            return "Bedrock response body missing."
        data = json.loads(body.read().decode("utf-8"))
        if isinstance(data, dict) and data.get("content"):
            return data["content"][0].get("text", "")
        return json.dumps(data)
    except Exception as exc:
        return f"Bedrock invocation failed: {exc}"


def lambda_handler(event, context):
    report_bucket = os.environ.get("REPORT_BUCKET")
    app_log_group = os.environ.get("APP_LOG_GROUP")
    waf_log_group = os.environ.get("WAF_LOG_GROUP")
    secret_id = os.environ.get("SECRET_ID")
    ssm_param_path = os.environ.get("SSM_PARAM_PATH", "/lab/db/")
    bedrock_model_id = os.environ.get("BEDROCK_MODEL_ID", "")
    sns_topic_arn = os.environ.get("SNS_TOPIC_ARN")
    logs_time_window = int(os.environ.get("LOGS_TIME_WINDOW_SECONDS", "900"))

    now = int(time.time())
    start = now - logs_time_window
    alarm = parse_alarm_event(event)

    app_logs = run_logs_query(
        app_log_group,
        "fields @timestamp, @message | sort @timestamp desc | limit 50",
        start,
        now,
    ) if app_log_group else []

    waf_logs = run_logs_query(
        waf_log_group,
        "fields @timestamp, action, httpRequest.clientIp as clientIp, httpRequest.uri as uri "
        "| stats count() as hits by action, clientIp, uri | sort hits desc | limit 25",
        start,
        now,
    ) if waf_log_group else []

    ssm_params = []
    if ssm_param_path:
        try:
            ssm_params = ssm.get_parameters_by_path(
                Path=ssm_param_path, WithDecryption=True, Recursive=True
            ).get("Parameters", [])
        except Exception:
            ssm_params = []

    secret_meta = None
    if secret_id:
        try:
            sec = secrets.describe_secret(SecretId=secret_id)
            secret_meta = {
                "arn": sec.get("ARN"),
                "name": sec.get("Name"),
            }
        except Exception:
            secret_meta = None

    prompt = {
        "incident": alarm,
        "app_logs": app_logs,
        "waf_logs": waf_logs,
        "ssm_params": ssm_params,
        "secret_meta": secret_meta,
    }
    bedrock_summary = bedrock_generate_summary(
        bedrock_model_id, json.dumps(prompt, indent=2, default=str)
    )

    incident_id = f"{alarm.get('AlarmName', 'incident')}-{now}"
    incident_id = slugify(incident_id)
    alarm_name = alarm.get("AlarmName", "unknown")
    alarm_state = alarm.get("NewStateValue", alarm.get("State", "unknown"))
    alarm_time = alarm.get("StateChangeTime", time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()))

    report = {
        "generated_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "incident_id": incident_id,
        "alarm": alarm,
        "app_logs": app_logs,
        "waf_logs": waf_logs,
        "ssm_params": ssm_params,
        "secret_meta": secret_meta,
        "bedrock_summary": bedrock_summary,
    }

    report_key = f"reports/ir-{incident_id}.json"
    md_key = f"reports/ir-{incident_id}.md"

    markdown = REPORT_TEMPLATE.format(
        incident_id=incident_id,
        title=alarm_name,
        impact="TBD",
        symptoms="TBD",
        detection="CloudWatch Alarm",
        severity="TBD",
        start_time="TBD",
        end_time="TBD",
        duration="TBD",
        alarm_time=alarm_time,
        first_error_time="TBD",
        triage_time="TBD",
        rca_time="TBD",
        fix_time="TBD",
        restore_time="TBD",
        alarm_clear_time="TBD",
        components="TBD",
        entry_point="ALB/WAF",
        downstream="RDS",
        regions="us-west-2",
        alarm_name=alarm_name,
        alarm_metric=alarm.get("MetricName", "unknown"),
        alarm_threshold=alarm.get("Threshold", "unknown"),
        alarm_state=alarm_state,
        app_log_summary=f"{len(app_logs)} records (last {logs_time_window}s)",
        waf_log_summary=f"{len(waf_logs)} records (last {logs_time_window}s)",
        ssm_path=ssm_param_path,
        secret_name=secret_meta["name"] if secret_meta else "unknown",
        drift_notes="TBD",
        root_cause_category="TBD",
        failure_mechanism="TBD",
        why_not_prevented="TBD",
        contributing_factors="TBD",
        actions_taken="TBD",
        validation_checks="TBD",
        recovery_evidence="TBD",
        prevent_immediate="TBD",
        prevent_short="TBD",
        prevent_long="TBD",
        cli_commands="TBD",
        queries_used="See evidence bundle",
        model_id=bedrock_model_id or "not configured",
    )

    if report_bucket:
        s3.put_object(
            Bucket=report_bucket,
            Key=report_key,
            Body=json.dumps(report, indent=2, default=str),
            ContentType="application/json",
        )
        s3.put_object(
            Bucket=report_bucket,
            Key=md_key,
            Body=markdown,
            ContentType="text/markdown",
        )

    if sns_topic_arn:
        sns.publish(
            TopicArn=sns_topic_arn,
            Subject="Report Ready",
            Message=json.dumps(
                {
                    "bucket": report_bucket,
                    "json_key": report_key,
                    "markdown_key": md_key,
                    "incident_id": incident_id,
                }
            ),
        )

    return {"ok": True, "report_key": report_key, "markdown_key": md_key}
